

<script>


  function arrayToList2(array) {
    if (array.length == 0) {
      return null // null表示空链表
    }
    var nodes = []

    // 针对数组里的每个元素创建一个结点（对象）
    for (var item of array) {
      var node = {
        val: item,
        next: null,
      }
      nodes.push(node)
    }

    // 把相邻的结点串起来
    for (var i = 0; i < nodes.length - 1; i++) {
      nodes[i].next = nodes[i + 1]
    }

    return nodes[0]
  }

  function arrayToList(array) {
    var helperNode = {
      val: 0,
      next: null,
    }

    var prevNode = helperNode

    for (var item of array) {
      var node = {
        val: item,
        next: null,
      }
      prevNode.next = node
      prevNode = node
    }

    return helperNode.next
  }

  // 通过数组创建链表，返回创建出来的链表头部
  function arrayToList3(array) {
    if (array.length == 0) {
      return null
    }

    var node = {
      val: array[0],
      next: null,
    }

    var restArray = array.slice(1)
    var restList = arrayToList3(restArray)

    node.next = restList
    return node
  }

  function listToArray(head) {
    var array = []

    if (head == null) {
      return array
    }

    // 只要head指向的还不会空
    while (head) {
      array.push(head.val)
      head = head.next
    }

    return array
  }

  // 递归写法
  function listToArray2(head) {
    if (head == null) {
      return []
    }

    return [head.val, ...listToArray2(head.next)]
  }

  // 将val放进链表结点中，并将结点加到head之前
  // 返回新的链表
  function prepend(val, head) {
    var node = {
      val: val,
      next: head,
    }
    return node
  }

  // 为链表末尾增加元素
  // 思考它的递归版本应该怎么写
  function append(val, head) {
    var node = {
      val: val,
      next: null,
    }

    if (head == null) {
      return node
    }

    // 顺着next指针遍历到链表的最后一个结点
    var p = head
    while (p.next) {
      p = p.next
    }

    p.next = node

    return head
  }

  // 获取连接head中的第idx项
  function nth(head, idx) {
    if (idx < 0 || head == null) {
      return undefined
    }

    while (idx > 0 && head) {
      head = head.next
      idx--
    }

    if (head) {
      return head.val
    } else {
      return undefined
    }
  }

  function nth2(head, idx) {
    if (head == null || idx < 0) {
      return undefined
    }
    if (idx == 0) {
      return head.val
    }

    return nth2(head.next, idx - 1)
  }

  // 为什么链表的每个函数基本都可以用递归写？
  // （啥函数不是都能吗？）并不是
  // 因为链表就是递归结构的
  // 链表是包含自身结构的结构
  /**
   * 链表不是数组
   * 链表的结点不是连续空间存储的
   * 而是每个结点存储了下一个结点的引用（地址）
   * 所以链接不能使用head[idx]访问到其中的项
   * 因为无法通过顺序就计算出结点所在的位置，因为结点的位置是无法预测的，而是需要从头结点顺着指针一步步前进到目标结点的
   * 但也因为这个原因，在链接的中部增加一个结点的话，也不需要挪动后续所有的元素
   * 数组查找快，增删慢
   * 链表查找慢，增删快
   * 
   * 
   */

  // 将value创建的结点插入到head链表中，插入后该结点的顺序应为idx
  function insert(head, idx, value) {

  }
  // 删除链接中顺序为idx的结点
  // 并返回可能的新的头结点
  function remove(head, idx) {
    if (head == null || idx < 0) {
      return head
    }
    if (idx == 0) {
      return head.next
    }

    // 把p移动要删除的结点的前面一个结点
    var p = head
    while(idx > 1 && p.next && p.next.next) {
      p = p.next
      idx--
    }

    p.next = p.next.next
  }



    // var node = {
    //     val: 3,
    //     next: null,
    // }
    // var node = new ListNode(3)
</script>